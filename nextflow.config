/*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Nextflow config file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Default config options for all compute environments
----------------------------------------------------------------------------------------

*/

nextflow.enable.moduleBinaries = true

params{
    // Pipeline parameters
    project_name                        = "project"
    // outdir                           = "${baseDir}"
    outdir                              = "./output"
    // input_seurat                     = "${baseDir}/data/Ovarian_cluster_object.RDS"
    input_seurat_object                 = "${baseDir}/data/Ovarian_cluster_object.RDS"
    
    // epithelial subsetting
    subset_col                          = "azimuth_labels"
    subset_values                       = "Epithelial"  // comma/semicolon/pipe-separated ok
    min_cells_per_sample_epith          = 150

    // QC / Leiden / signatures
    complexity_filter                   = 1000
    mito_filter                         = 20
    hvg_keep                            = 7000
    dims_use_max                        = 50
    resolution                          = 1.0
    genes_per_program                   = 50
    sig_th                              = 0.005

    // MP clustering
    mp_num                              = 13
    mp_min_size                         = 4
    mp_max_size_frac                    = 0.5
    seed                                = 1234


    // Notebooks
    // notebook_metaprog                = "${baseDir}/modules/local/MetaProg-DE/notebook_metaprog.qmd"
    leiden_qmd                          = "${baseDir}/modules/local/MetaProg-DE/Metaprog_leiden.qmd"
    nmfprep_qmd                         = "${baseDir}/modules/local/MetaProg-DE/Metaprog_NMFprepprocessing.qmd" 
    nmf_qmd                             = "${baseDir}/modules/local/MetaProg-DE/Metaprog_NMF.qmd"
    postnmf_qmd                         = "${baseDir}/modules/local/MetaProg-DE/Metaprog_PostNMF.qmd"

    // Optional: minimum number of NMF results required to run PostNMF
    // (not strictly neededâ€”only if you add the guard in the subworkflow)
    post_min_n =        2

    // Metaprog parameters
    max_cells                           = 0        // '0' will skip maxcell filtering. Any integer greater. than '0' will filter the sample to that number.
    min_cells                           = 100
    rank_lb                             = 3
    rank_ub                             = 5
    nrun                                = 2
    batch_size                          = 5
    // batch_size must be kept under 8 to avoid memory exhaustion 
    min_intersect_initial               = 12
    min_intersect_cluster               = 12
    min_group_size                      = 4
    intra_min                           = 25
    intra_max                           = 12
    inter_min                           = 8


    // Quarto parameters
    page_config                         = "${baseDir}/assets/template/_quarto.yml"
    template                            = "${baseDir}/assets/template/*"

    // Max resource options
    max_cpus                            = 24
    max_memory                          = '250 GB'
    max_time                            = '1000 h'

}


process {
    containerOptions = { getContainerOptions(workflow.containerEngine) }
    // stageInMode = 'copy'
    stageInMode = 'symlink'
    // Per-step resources (tune to your cluster / data size)
    withName: METAPROG_LEIDEN   { cpus = 16;  memory = '60 GB'; time = '100 h'  }
    withName: METAPROG_NMF_PREP { cpus = 16;  memory = '60 GB'; time = '100 h' }
    withName: METAPROG_NMF      { cpus = 24;  memory = '250 GB'; time = '1000 h'; maxForks = 8 }  
    withName: METAPROG_POST     { cpus = 4;  memory = '16 GB'; time = '20 h'  }
}
// =========================
// Reports 
// =========================



def getContainerOptions (executor) {
    if (executor == 'docker') {
        return '-u root:root -e USERID=$UID -e XDG_CACHE_HOME=tmp/quarto_cache_home -e XDG_DATA_HOME=tmp/quarto_data_home -e QUARTO_PRINT_STACK=true'
    } else if (executor == 'singularity') {
        return '--env USERID=$UID --env XDG_CACHE_HOME=tmp/quarto_cache_home --env XDG_DATA_HOME=tmp/quarto_data_home --env QUARTO_PRINT_STACK=true'
    } else {
        return ''
    }
}


// Load nf-core custom profiles from different Institutions
profiles {
    docker {
        docker.enabled         = true
        docker.fixOwnership    = true
        singularity.enabled    = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
    }

    singularity {
        singularity.enabled    = true
        singularity.autoMounts = true
        docker.enabled         = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
    }
    mskcc_iris {
        singularity {
            enabled = true
            autoMounts = true
        }
        process {
            executor = 'slurm'
            queue = 'componc_cpu,componc_gpu'
        }
        executor {
            name = 'slurm'
            queueSize = 25
        }
    }
    
    test      { includeConfig 'conf/test.config' }
    seadragon { includeConfig 'conf/institution.config' }

}


// Load modules.config for DSL2 module specific options
includeConfig 'conf/modules.config'

// Load base.config by default for all pipelines
includeConfig 'conf/base.config'

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}